package Contracts;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.*;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;

public class Compiler {

   private final static Logger logger = Logger.getLogger(Compiler.class);

   /**
    * Creates a temporary directory and create a solidity contract source code
    * file inside that directory. The output files generated by compiler will
    * also be present in same directory
    * 
    * @param contents
    * @return
    */
   private static Path createSourceFiles(String contents) throws IOException {
      // Create a random directory
      FileAttribute<Set<PosixFilePermission>> attr
         = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString("rwxrwxrwx"));
      Path workDir = Files.createTempDirectory("helen-solc", attr);
      // Note: Ideally we should name this file from the name of the
      // contract, i.e if contract is `Contract Manager {..` then we
      // should name file as `Manager.sol` however that will require
      // parsing of the `contents` string. Instead we create a source file
      // with generic name and let the compiler compiler this file.
      // compiler will actually parse the source code and generate output
      // files with proper names (Manager.bin, Manager_meta.json etc)
      // We can then use these file names to deduce the name of contract
      Path sourceFile = workDir.resolve("source.sol");
      Files.createFile(sourceFile, attr);
      try (BufferedWriter writer
         = Files.newBufferedWriter(sourceFile, Charset.defaultCharset())) {
         writer.write(contents);
      } catch (IOException e) {
         throw e;
      }
      return sourceFile;
   }

   private static boolean isBytecodeFile(Path file) {
      return file.toString().endsWith(".bin");
   }

   private static boolean isMetadataFile(Path file) {
      return file.toString().endsWith("_meta.json");
   }

   /**
    * Extracts the name of the contract from given Path to the bytecode file (
    * <ContractName>.bin) file or a from given Path of the metadata
    * (<ContractName>_meta.json) file
    * 
    * @param file
    *           Path to the bytecode or metadata file
    * @return Name of the contract
    */
   private static String
           extractContractName(Path file) throws IllegalArgumentException {
      // If its a bytecode file then its name will be of the form
      // <ContractName>.bin. If its a metadata file then its name will be of
      // the form <ContractName>_meta.json
      String fileName = file.getFileName().toString();
      if (isBytecodeFile(file) && fileName.indexOf(".") > 0) {
         return fileName.substring(0, fileName.lastIndexOf("."));
      } else if (isMetadataFile(file) && fileName.indexOf("_meta.json") > 0) {
         return fileName.substring(0, fileName.lastIndexOf("_meta.json"));
      } else {
         throw new IllegalArgumentException("Only bytecode or metadata file "
            + "Path " + "are supported");
      }
   }

   private static String readFileContents(Path file) throws IOException {
      byte[] bytes = Files.readAllBytes(file);
      return new String(bytes);
   }

   /**
    * Reads all the *.abi files in given directory and returns a Map with key as
    * the name of the contract and value as the contents of its bytecode
    * 
    * @param dir
    *           The directory from which bytecode files should be read
    * @return The map of key-value pairs of contract name and its bytecode
    */
   private static Map<String, String>
           getCompiledByteCodeFrom(Path dir) throws IOException,
                                             DirectoryIteratorException {
      Map<String, String> byteCodeMap = new HashMap<>();
      try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
         for (Path file : stream) {
            if (isBytecodeFile(file)) {
               byteCodeMap.put(extractContractName(file),
                               readFileContents(file));
            }
         }
      } catch (IOException | DirectoryIteratorException e) {
         throw e;
      }
      return byteCodeMap;
   }

   /**
    * Reads all the *_meta.json files in given directory and returns a Map with
    * key as the name of the contract and value as the contents of its metadata
    * 
    * @param dir
    *           The directory from which metadata files should be read
    * @return The map of key-value pairs of contract name and its metadata
    */
   private static Map<String, String>
           getMetadataFrom(Path dir) throws IOException,
                                     DirectoryIteratorException {
      Map<String, String> metadataMap = new HashMap<>();
      try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
         for (Path file : stream) {
            if (isMetadataFile(file)) {
               metadataMap.put(extractContractName(file),
                               readFileContents(file));
            }
         }
      } catch (IOException | DirectoryIteratorException e) {
         throw e;
      }
      return metadataMap;
   }

   private static String readStream(InputStream is) throws IOException {
      String line;
      BufferedReader reader = new BufferedReader(new InputStreamReader(is));
      StringBuilder sb = new StringBuilder();
      while ((line = reader.readLine()) != null) {
         sb.append(line);
      }
      return sb.toString();
   }

   /**
    * Compiles the given solidity contract code and returns the result of
    * compilation. compiler result contains the compiled bytecode and the
    * metadata for the contract. This method invokes the pre-installed `solc`
    * command. Hence, we first have to write the give solidity contract code
    * into a file which we then pass a `solc` command argument.
    * 
    * @param solidityCode
    * @return The result object containing compilation result.
    */
   public static Result compile(String solidityCode) {
      Result result = new Result();
      try {
         Path sourceFile = createSourceFiles(solidityCode);
         // We need a command of form
         // solc --bin --metadata -o outputDir inputFile
         String command[] = { "solc", "--bin", "--metadata", "-o",
            sourceFile.getParent().toString(), sourceFile.toString() };

         String line;
         Process compileProcess = Runtime.getRuntime().exec(command);
         // Get process output - note in this case output should be read
         // from input stream
         String stdOut = readStream(compileProcess.getInputStream());
         // Get process input
         String stdErr = readStream(compileProcess.getErrorStream());

         compileProcess.waitFor();
         // get process exit code
         int exitCode = compileProcess.exitValue();

         if (exitCode == 0) {
            result.setSuccess(true);
            // read bin and json files for bytecode and metadata
            result.setByteCodeMap(getCompiledByteCodeFrom(sourceFile.getParent()));
            result.setMetadataMap(getMetadataFrom(sourceFile.getParent()));
         }

         result.setStdout(stdOut);
         result.setStderr(stdErr);

      } catch (IOException | InterruptedException e) {
         logger.warn("Error in compilation:" + e);
      }
      return result;
   }

   public static void main(String args[]) {
      Compiler c = new Compiler();
      try {
         Result r
            = c.compile(c.readFileContents(Paths.get("/tmp/ABCD/MoneyMover.sol")));
         System.out.println(r);
      } catch (Exception e) {
         logger.warn(e);
      }
   }

   public static class Result {
      // compilation success or failure
      boolean success = false;
      // standard output of compilation
      String stdout = null;
      // standard error of compilation
      String stderr = null;
      // Bytecode of the compiled contract, if successful
      Map<String, String> byteCodeMap = null;
      // Metadata of the compiled contract, if successful
      Map<String, String> metadataMap = null;

      public void setSuccess(boolean success) {
         this.success = success;
      }

      public void setStdout(String stdout) {
         this.stdout = stdout;
      }

      public void setStderr(String stderr) {
         this.stderr = stderr;
      }

      public void setByteCodeMap(Map<String, String> byteCodeMap) {
         this.byteCodeMap = byteCodeMap;
      }

      public void setMetadataMap(Map<String, String> metadataMap) {
         this.metadataMap = metadataMap;
      }
   
      public boolean isSuccess() {
         return success;
      }
   
      public String getStdout() {
         return stdout;
      }
   
      public String getStderr() {
         return stderr;
      }
   
      public Map<String, String> getByteCodeMap() {
         return byteCodeMap;
      }
   
      public Map<String, String> getMetadataMap() {
         return metadataMap;
      }
   
      @Override
      public String toString() {
         StringBuilder sb = new StringBuilder();
         sb.append("Compilation Success: ")
           .append(success)
           .append("\n")
           .append("stdout: ")
           .append(stdout)
           .append("\n")
           .append("stderr: ")
           .append(stderr)
           .append("\n");
         if (byteCodeMap != null && metadataMap != null) {
            for (Map.Entry<String, String> e : byteCodeMap.entrySet()) {
               sb.append(e.getKey() + "=> [" + e.getValue() + "]");
            }
            for (Map.Entry<String, String> e : metadataMap.entrySet()) {
               sb.append(e.getKey() + "=> [" + e.getValue() + "]");
            }
         }
         return sb.toString();
      }
   }

}
